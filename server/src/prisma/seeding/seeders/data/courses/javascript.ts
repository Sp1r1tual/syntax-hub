import { ICourseSeed } from "./index";

export const javascriptCourse: ICourseSeed = {
  id: "java-script",
  slug: "java-script",
  title: "JavaScript",
  description:
    "Основний інструмент для роботи з вебом та сучасними додатками. Додає життя вашому сайту: кнопки, анімації та динамічний контент.",
  groupKey: "frontend",
  icon: "https://naqhdzpocsklzkhutzwc.supabase.co/storage/v1/object/sign/syntax-hub/courses/groups/javascript-logo.png?token=eyJraWQiOiJzdG9yYWdlLXVybC1zaWduaW5nLWtleV8xZDFhZmE1NS00MzFhLTQxMDgtOTE0ZS02NTcxMmE0YjZkNGIiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJzeW50YXgtaHViL2NvdXJzZXMvZ3JvdXBzL2phdmFzY3JpcHQtbG9nby5wbmciLCJpYXQiOjE3Njc1MzQ3ODAsImV4cCI6NDg4OTU5ODc4MH0.TqQOpquP1Q0mO3x73NIoXpDB0OvtJAKzg-e17UVE3E4",
  order: 3,
  authorIds: ["eaab3633-8366-4ef2-8cb4-e3841c0f4702"],
  topics: [
    {
      id: "js-topic-1",
      title: "Основи",
      order: 1,
      questions: [
        {
          id: "js-question-1",
          text: "Типи даних",
          order: 1,
          content: `Вітаю на початку курсу з JavaScript

Це мова програмування, без якої сучасна веб-розробка просто не існує. JavaScript відповідає за логіку, взаємодію з користувачем, роботу з даними та поведінку сторінки в браузері і не тільки. Якщо ти хочеш реально розуміти, що відбувається «під капотом» – без JS нікуди.

Почнемо з бази – типів даних.

Типи даних визначають:
- як значення зберігається в пам’яті;
- як воно копіюється;
- як порівнюється;
- як поводиться в операціях.

У JavaScript існує 8 основних типів даних:  
number, string, boolean, null, undefined, object, symbol, bigint.

З них **7 є примітивними**:
- number – числа (цілі та дробові)
- string – рядки
- boolean – логічні значення true / false
- null – явна відсутність значення
- undefined – значення не присвоєне
- symbol – унікальні ідентифікатори
- bigint – числа довільної довжини

І **1 непримітивний тип** – object.

Об’єкти використовуються для зберігання складних структур даних: масивів, функцій, об’єктів, дат тощо, но про це згодом.

Важливо розуміти цю різницю з самого початку, бо примітиви копіюються за значенням, а об’єкти – за посиланням.

Давайте розглянемо усе більш детально.

## Примітивні типи даних

**Boolean (Логічний тип)**

Булеві значення можуть бути тільки true (правда) або false (хибність). Вони використовуються для логічних перевірок, умов та контролю виконання коду. Це найпростіший тип даних з лише двома можливими значеннями.

\`\`\`javascript
// ===== BOOLEAN =====
const e = true;
const f = false;

// Логічні значення
e === f; // false
true === true; // true
\`\`\`

> === – це оператор строгого порівняння, він повертає true або false при порівнянні значень та типів одночасно.

**Number (Числа)**

Коли ми присвоюємо число змінній, створюється копія значення. Кожна змінна зберігає своє власне число в пам'яті. Це означає, що змінні з однаковими числами є незалежними одна від одної.

\`\`\`javascript
// ===== NUMBER =====
const a = 10;
const b = 10;

// Примітиви копіюються за значенням
// a і b незалежні
a === b; // true

let c = a;
c = 20;
// a залишилось 10, c стало 20
\`\`\`

**String (Рядки)**

Рядки працюють так само, як числа – це примітивний тип. Кожна змінна містить своє власне текстове значення, яке не залежить від інших змінних. Навіть якщо два рядки виглядають однаково, вони можуть бути різними об'єктами в пам'яті.

\`\`\`javascript
// ===== STRING =====
const str1 = "js";
const str2 = "ts";

// Рядки теж примітиви
str1 === str2; // false
str1 === "js"; // true
\`\`\`

**Undefined (Невизначене значення)**

Коли змінна оголошена, але їй не присвоєно жодного значення, вона автоматично отримує тип undefined. Це стандартна поведінка JavaScript – показати, що значення ще не задане.

\`\`\`javascript
// ===== UNDEFINED =====
let h;
// Значення не присвоєне
h === undefined; // true
\`\`\`

**Null (Порожнє значення)**

null використовується, коли ми свідомо хочемо вказати, що значення відсутнє або має бути порожнім. Це не те саме, що undefined – null є явним вибором програміста, а не автоматичним значенням.

\`\`\`javascript
// ===== NULL =====
const g = null;
// Явна відсутність значення
g === null; // true
\`\`\`

**Symbol (Унікальний ідентифікатор)**

Symbol створює унікальний ідентифікатор, який ніколи не повторюється. Навіть якщо ми передамо однаковий опис при створенні двох символів, вони все одно будуть різними. Символи часто використовуються як ключі об'єктів, коли потрібна гарантована унікальність.

\`\`\`javascript
// ===== SYMBOL =====
const s1 = Symbol("id");
const s2 = Symbol("id");
// Кожен symbol унікальний
s1 === s2; // false
\`\`\`

**BigInt (Великі цілі числа)**

BigInt використовується для роботи з дуже великими цілими числами, які перевищують максимальне безпечне значення для звичайного типу Number (9007199254740991). Для створення BigInt додається літера n в кінці числа.

\`\`\`javascript
// ===== BIGINT =====
const big1 = 9007199254740991n;
const big2 = 9007199254740991n;
// Дуже великі числа
big1 === big2; // true
\`\`\`

## Непримітивні типи даних

**Object (Об'єкт)**

Об'єкти – це фундаментально інший тип даних. Вони зберігаються не за значенням, а за посиланням. Це означає, що змінна містить не сам об'єкт, а адресу (посилання) на місце в пам'яті, де зберігається об'єкт. Коли ми змінюємо об'єкт через одну змінну, зміни видно через всі інші змінні, що вказують на той самий об'єкт.

\`\`\`javascript
// ===== OBJECT =====
const obj1 = { value: 10 };
const obj2 = { a: 10, b: "abc", obj1 };

// Об'єкти порівнюються за посиланням
obj1 === obj2; // false

const obj3 = obj1;
// Тепер obj3 та obj1 — одне й те саме
obj1 === obj3; // true

obj3.value = 99;
// Зміна через одне посилання впливає на обидва
obj1.value; // 99
\`\`\`

**Що з масивами?**

Звідки взялись масиви, якщо згадувалось про 8 типів? Все просто: масив – це спеціальний вид об'єкта, який дозволяє зберігати колекцію значень у певному порядку. Хоч масив виглядає як список, в JavaScript він повністю є об'єктом під капотом.

**Array (Масив)**

Масиви дозволяють зберігати упорядкований список значень. Вони теж є об'єктами, тому працюють за посиланням, а не за значенням. Якщо ми присвоюємо масив іншій змінній, обидві змінні вказують на один і той самий масив у пам'яті.

\`\`\`javascript
// ===== ARRAY (object) =====
const arr1 = [1, 2, 3];
const arr2 = [1, "abc", obj1];

// Масиви теж об'єкти
arr1 === arr2; // false

const arr3 = arr1;
// Тепер arr3 та arr1 — одне й те саме
arr1 === arr3; // true
\`\`\`

## Основні типи даних

| Тип даних | Приклад | Опис |
|-----------|---------|------|
| Number | 42, 3.14, NaN, Infinity | Числа (цілі та дробові) |
| BigInt | 123n, 9007199254740991n | Великі цілі числа довільної довжини |
| String | 'Привіт', "Світ", &#96;Привіт \${name}\&#96; | Текстові рядки |
| Boolean | true, false | Логічний тип (правда/хибність) |
| Null | null | Явна відсутність значення |
| Undefined | undefined | Значення не присвоєно |
| Symbol | Symbol('id'), Symbol.for('key') | Унікальний ідентифікатор |
| Object | {}, [], function(){}, new Date() | Колекції та складні структури |

Тепер ти знаєш основу основ – **8 типів даних у JavaScript**. Це фундамент, на якому будується вся робота з даними в JS.

Найважливіше, що потрібно запам'ятати:
- **Примітиви** (number, string, boolean, null, undefined, symbol, bigint) копіюються **за значенням**
- **Об'єкти** (object, array) копіюються **за посиланням**

Ця різниця критично важлива – вона впливає на те, як твій код працює з даними. Якщо щось поки не до кінця зрозуміло – не переживай, у наступних темах ми будемо постійно працювати з цими типами, і все стане набагато ясніше на практиці.

**Далі переходимо до динамічної типізації** – дізнаємося, як JavaScript автоматично конвертує один тип в інший, і як це контролювати.
`,
        },
        {
          id: "js-question-2",
          text: "Динамічна типізація",
          order: 2,
          content: `JavaScript – це мова з динамічною типізацією. Що це означає на практиці? Тип змінної визначається не при оголошенні, а в момент присвоєння значення. Більше того – одна й та сама змінна може змінювати свій тип протягом виконання програми.
          
**Що таке динамічна типізація?**
          
У мовах зі статичною типізацією (Java, C++, TypeScript) ти спочатку вказуєш тип змінної, і він не змінюється:
          
\`\`\`java
// Java (статична типізація)
int number = 42;        // тип int
number = "Hello";       // Помилка! Не можна присвоїти рядок
\`\`\`

У JavaScript все інакше – змінна може бути будь-якого типу, і цей тип може змінюватись:

\`\`\`javascript
// JavaScript (динамічна типізація)
let value = 42;         // number
console.log(typeof value); // "number"

value = "Hello";        // тепер string
console.log(typeof value); // "string"

value = true;           // тепер boolean
console.log(typeof value); // "boolean"

value = { name: "JS" }; // тепер object
console.log(typeof value); // "object"
\`\`\`

> console.log() – це команда, яка виводить інформацію на екран (у консоль браузера або середовища розробки). Використовується, щоб подивитися, що зараз зберігається в змінній або чи взагалі код працює...

> typeof – це оператор, який показує тип даних змінної.

## Переваги динамічної типізації

**1. Гнучкість та швидкість написання коду**

Не потрібно заздалегідь думати про типи – просто пишеш код:

\`\`\`javascript
let data = fetchFromServer(); // Не знаємо заздалегідь, що прийде
// Може бути число, рядок, об'єкт, масив – все спрацює
\`\`\`

**2. Простіший синтаксис**

Менше коду, менше оголошень типів:

\`\`\`javascript
// JavaScript
let name = "Іван";
let age = 25;
let isStudent = true;

// Java (для порівняння)
// String name = "Іван";
// int age = 25;
// boolean isStudent = true;
\`\`\`

**3. Швидке прототипування**

Можна швидко тестувати ідеї без необхідності продумувати типи наперед:

\`\`\`javascript
function process(data) {
  // Працює з будь-якими даними
  console.log(data);
}

process(42);
process("текст");
process([1, 2, 3]);
process({ key: "value" });
\`\`\`

> function() {} – це функція — шматок коду, який можна викликати і виконувати скільки завгодно разів. Простими словами: функція — це інструкція “зроби ось це”. Детально, як працюють функції, чим вони відрізняються між собою і чому це важливо — розберемо пізніше.

## Недоліки динамічної типізації

**1. Помилки виявляються пізніше**

Помилки з типами з'являються тільки під час виконання коду, а не при компіляції:

\`\`\`javascript
let price = "100";  // Рядок замість числа

// Код запуститься, але результат буде несподіваним
let total = price * 2;
console.log(total); // 200 (працює через автоматичне перетворення)

let sum = price + 50;
console.log(sum);   // "10050" (конкатенація замість додавання)
\`\`\`

**2. Складніше відловлювати баги**

Тип може змінитись у будь-якому місці програми, і це не завжди очевидно:

\`\`\`javascript
function calculate(value) {
  // Очікуємо число, але хтось може передати що завгодно
  return value * 2;
}

calculate(10);        // 20
calculate("10");      // 20 (працює через перетворення)
calculate("hello");   // NaN
calculate(null);      // 0
calculate(undefined); // NaN
\`\`\`

**3. Потрібно більше перевірок**

Доводиться частіше перевіряти типи вручну:

\`\`\`javascript
function processUser(user) {
  // Перевіряємо, чи user це об'єкт
  if (typeof user !== 'object' || user === null) {
    console.error("Очікується об'єкт");
    return;
}
  
  // Перевіряємо, чи є властивість name
  if (typeof user.name !== 'string') {
    console.error("Очікується рядок у полі name");
    return;
  }
  
  console.log(&#96;Привіт, \${user.name}\&#96;);
}
\`\`\`

## Неявне перетворення типів

JavaScript автоматично перетворює типи даних, коли це необхідно для виконання операції. Це може призводити до несподіваних результатів, якщо не розуміти, як це працює.

**Додавання (+) – особливий оператор:**

\`\`\`javascript
// Число + число = додавання
console.log(5 + 3);        // 8

// Рядок + число = з'єднання рядків
console.log("5" + 3);      // "53"
console.log(5 + "3");      // "53"

// Рядок + рядок = з'єднання рядків
console.log("5" + "3");    // "53"
console.log("Hello" + " World");  // "Hello World"
\`\`\`

**Інші арифметичні операції (-, \*, /):**

Всі інші оператори намагаються перетворити значення в числа:

\`\`\`javascript
// Віднімання – рядки стають числами
console.log("10" - 5);     // 5
console.log("20" - "5");   // 15

// Множення – рядки стають числами
console.log("10" * 2);     // 20
console.log("5" * "3");    // 15

// Ділення – рядки стають числами
console.log("20" / 4);     // 5
console.log("10" / "2");   // 5
\`\`\`

**Що таке NaN (Not a Number)?**

Якщо JavaScript не може перетворити щось в число, він повертає NaN (не-число):

\`\`\`javascript
// Неможливо перетворити в число
console.log("hello" - 5);      // NaN
console.log("abc" * 2);        // NaN
console.log("test" / 3);       // NaN
\`\`\`

**Порівняння: == vs ===**

Оператор == перетворює типи перед порівнянням, а === порівнює без перетворення:

\`\`\`javascript
// == (нестроге) – перетворює типи
console.log(5 == "5");         // true (рядок стає числом)
console.log(1 == true);        // true (true стає 1)
console.log(0 == false);       // true (false стає 0)

// === (строге) – НЕ перетворює типи
console.log(5 === "5");        // false (різні типи!)
console.log(1 === true);       // false (різні типи!)
console.log(0 === false);      // false (різні типи!)
\`\`\`

**Практичний приклад проблеми:**

\`\`\`javascript
// Хочемо додати два числа
let a = "10";  // Це рядок (наприклад, з форми на сайті)
let b = "20";  // Це теж рядок

// Спроба 1 – помилка!
console.log(a + b);  // "1020" ❌ (з'єднання рядків!)

// Спроба 2 – правильно!
console.log(Number(a) + Number(b));  // 30 ✅ (додавання чисел)
\`\`\`

**Як уникати проблем:**

\`\`\`javascript
// ❌ ПОГАНО – може бути несподіванка
let result = userInput + 10;  // Якщо userInput = "5", то "510"

// ✅ ДОБРЕ – явно перетворюємо в число
let result = Number(userInput) + 10;  // Якщо userInput = "5", то 15

// ✅ ДОБРЕ – використовуємо строге порівняння
if (value === 5) {  // Перевіряє і тип, і значення
  console.log("Точно п'ять!");
}
\`\`\`

**Запам'ятай:**

- Оператор + з рядками **з'єднує**, а не додає
- Інші оператори (-, *, /) перетворюють в числа
- Завжди використовуй === замість ==
- Якщо не впевнений – перетворюй типи явно через Number(), String() або Boolean()

## Перевірка типів: оператор typeof

Щоб дізнатись тип значення, використовуй оператор typeof:
          
\`\`\`javascript
// ===== ПРИМІТИВНІ ТИПИ =====

console.log(typeof 42);           // "number"
console.log(typeof 3.14);         // "number"
console.log(typeof NaN);          // "number"
console.log(typeof Infinity);     // "number"

console.log(typeof "hello");      // "string"
console.log(typeof 'world');      // "string"

console.log(typeof true);         // "boolean"
console.log(typeof false);        // "boolean"

console.log(typeof undefined);    // "undefined"

console.log(typeof 123n);         // "bigint"

console.log(typeof Symbol("id")); // "symbol"

// ===== НЕПРИМІТИВНІ ТИПИ =====

console.log(typeof {});           // "object"
console.log(typeof { a: 1 });     // "object"

console.log(typeof []);           // "object" ⚠️
console.log(typeof [1, 2, 3]);    // "object" ⚠️

console.log(typeof function(){}); // "function" ✨
\`\`\`

## Важливі особливості typeof

**1. null повертає "object" (це баг!)**

Це історична помилка в JavaScript, яку неможливо виправити без руйнування існуючого коду:

\`\`\`javascript
console.log(typeof null); // "object"

// Правильна перевірка на null:
let value = null;
console.log(value === null); // true
\`\`\`

**2. Масиви повертають "object"**

Для перевірки масивів використовуй Array.isArray():

\`\`\`javascript
console.log(typeof [1, 2, 3]);      // "object"
console.log(Array.isArray([1, 2, 3])); // true

let arr = [1, 2, 3];
console.log(Array.isArray(arr));    // true
console.log(Array.isArray("text")); // false
console.log(Array.isArray({}));     // false
\`\`\`

**3. Функції повертають "function"**

Хоча функції технічно є об'єктами, typeof повертає для них спеціальне значення:

\`\`\`javascript
function greet() {
  return "Hello";
}

console.log(typeof greet); // "function"
\`\`\`

## Підсумок

Динамічна типізація в JavaScript означає:

- Тип змінної визначається автоматично при присвоєнні значення;
- Змінна може змінювати свій тип протягом виконання програми;
- Це дає гнучкість, але вимагає додаткових перевірок.

Головні інструменти для роботи з типами:

- typeof – для перевірки типу значення;
- Array.isArray() – для перевірки масивів;
- value === null – для перевірки null.

Пам'ятай:

- Завжди перевіряй типи даних у критичних місцях;
- Будь обережним з автоматичним перетворенням типів;
- Використовуй перевірки, щоб уникнути несподіваних помилок.
`,
        },
      ],
    },
    { id: "js-topic-3", title: "Умови", order: 2, questions: [] },
    { id: "js-topic-4", title: "Функції та scope", order: 3, questions: [] },
    { id: "js-topic-5", title: "Цикли", order: 4, questions: [] },
    {
      id: "js-topic-6",
      title: "Об'єкти та прототипи",
      order: 5,
      questions: [],
    },
    { id: "js-topic-7", title: "this та контекст", order: 6, questions: [] },
    {
      id: "js-topic-8",
      title: "Масиви та структури даних",
      order: 7,
      questions: [],
    },
    { id: "js-topic-9", title: "Класи", order: 8, questions: [] },
    {
      id: "js-topic-10 ",
      title: "Асинхронність та Event Loop",
      order: 9,
      questions: [],
    },
    { id: "js-topic-11", title: "Дебагінг", order: 10, questions: [] },
    { id: "js-topic-12", title: "DOM та події", order: 11, questions: [] },
  ],
};
